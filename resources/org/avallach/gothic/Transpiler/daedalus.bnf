{
	tokens =
	[
		//keywords
		CLASS = "class"
		PROTOTYPE = "prototype"
		INSTANCE = "instance"
		CONST = "const"
		VAR = "var"
		IF = "if"
		ELSE = "else"
		FUNC = "func"
		RETURN = "return"

		//builtin primitive types
		VOID = "void"
		FLOAT = "float"
		INT = "int"
		STRING = "string"

		//block boundaries
		LEFT_BRACE = "{"
		RIGHT_BRACE = "}"
		LEFT_PAREN = "("
		RIGHT_PAREN = ")"
		LEFT_BRACKET = "["
		RIGHT_BRACKET = "]"

		//math ops
		PLUS_OP = "+"
		MINUS_OP = "-"
		MUL_OP = "*"
		DIV_OP = "/"
		REM_OP = "%"

		//rel ops
		LESS_THAN = "<"
		GREATER_THAN = ">"
		EQUALS_OP = "=="
		NOT_EQUALS_OP = "!="
		LESS_THAN_OR_EQUAL_OP = "<="
		GREATER_THAN_OR_EQUAL_OP = ">="

		//bit ops
		BIT_SHIFT_LEFT_OP = "<<"
		BIT_SHIFT_RIGHT_OP = ">>"
		BIT_OR_OP = "|"
		BIT_AND_OP = "&"
		NEGATION_OP = "!"

		//logical ops
		AND_OP = "&&"
		OR_OP = "||"

		//misc
		SEMICOLON = ";"
		COMMA = ","
		ASSIGNMENT_OP = "="
		DOT = "."

		//regex tokens
		IDENTIFIER_TOKEN = "regexp:[a-zA-Z_]([a-zA-Z0-9_])*"
		NUMBER_LITERAL = "regexp:[0-9]+(\.[0-9]+)?"
		STRING_LITERAL = "regexp:\"[^\r\n\"]*\""
		LINE_COMMENT = "regexp://.*"
		BLOCK_COMMENT = "regexp:/\*([^*]|\*+[^*/])*(\*+/)?"
		WHITESPACE = "regexp:[ \t\r\n]+"
	]
}

private DaedalusFile ::= { Definition }*
Definition ::= ( ConstDef | ClassDef | InstanceDef | VarDef | PrototypeDef | FuncDef ) ";"
ConstDef ::= "const" TypeReference NameNode "=" Literal {pin=1}
TypeReference ::= ReferenceNode | "void" | "float" | "int" | "string" | "func"
NameNode ::= IDENTIFIER_TOKEN
ReferenceNode ::= IDENTIFIER_TOKEN
Literal ::= NUMBER_LITERAL | STRING_LITERAL
ClassDef ::= "class" NameNode "{" { VarDef ";" }* "}" {pin=1}
VarDef ::= "var" TypeReference NameNode { "," NameNode }* [ ArrayIndex ] {pin=1}
ArrayIndex ::= "[" ( NUMBER_LITERAL | ReferenceNode ) "]" {pin=1}
InstanceDef ::= "instance" NameNode { "," NameNode }* "(" ReferenceNode ")" [ "{" { ( Assignment | FunctionCall ) ";" }* "}" ] {pin=1}
PrototypeDef ::= "prototype" NameNode "(" ReferenceNode ")" "{" { Assignment ";" }* "}" {pin=1}
Assignment ::= Expression "=" Expression
FuncDef ::= "func" TypeReference NameNode ParameterList StatementBlock {pin=1}
ParameterList ::= "(" [ VarDef { "," VarDef }* ] ")" {pin=1}
StatementBlock ::= "{" { ( VarDef | Assignment | FunctionCall | ( "return" [ Expression ] ) | IfStatement ) ";" }* "}"
IfStatement ::= "if" "(" Expression ")" StatementBlock { "else" "if" "(" Expression ")" StatementBlock }* [ "else" StatementBlock ]
FunctionCall ::= ReferenceNode "(" [ Expression { "," Expression }* ] ")"
UnaryOperator ::= "-" | "+" | "!"
private MathOp ::= "+" | "-" | "*" | "/" | "%"
private RelOp ::= "<" | ">" | "==" | "!=" | "<=" | ">="
private BitOp ::= "<<" | ">>" | "|" | "&"
private LogicalOp ::= "&&" | "||"
Operator ::= MathOp | RelOp | BitOp | LogicalOp | "."
SimpleExpression ::= Literal | FunctionCall | ( ReferenceNode [ ArrayIndex ] )
private Expression ::= [ UnaryOperator ] ( SimpleExpression { Operator Expression }* ) | ( "(" Expression ")" { Operator Expression }* )