{
	tokens =
	[
		//keywords
		CLASS = "class"
		PROTOTYPE = "prototype"
		INSTANCE = "instance"
		CONST = "const"
		VAR = "var"
		IF = "if"
		ELSE = "else"
		FUNC = "func"
		RETURN = "return"

		//builtin primitive types
		VOID = "void"
		FLOAT = "float"
		INT = "int"
		STRING = "string"

		//block boundaries
		LEFT_BRACE = "{"
		RIGHT_BRACE = "}"
		LEFT_PAREN = "("
		RIGHT_PAREN = ")"
		LEFT_BRACKET = "["
		RIGHT_BRACKET = "]"

		//math ops
		PLUS_OP = "+"
		MINUS_OP = "-"
		MUL_OP = "*"
		DIV_OP = "/"
		REM_OP = "%"

		//rel ops
		LESS_THAN = "<"
		GREATER_THAN = ">"
		EQUALS_OP = "=="
		NOT_EQUALS_OP = "!="
		LESS_THAN_OR_EQUAL_OP = "<="
		GREATER_THAN_OR_EQUAL_OP = ">="

		//bit ops
		BIT_SHIFT_LEFT_OP = "<<"
		BIT_SHIFT_RIGHT_OP = ">>"
		BIT_OR_OP = "|"
		BIT_AND_OP = "&"

		//logical ops
		AND_OP = "&&"
		OR_OP = "||"

		//misc
		SEMICOLON = ";"
		COMMA = ","
		ASSIGNMENT_OP = "="
		DOT = "."

		//regex tokens
		IDENTIFIER_TOKEN = "regexp:[a-zA-Z_]([a-zA-Z0-9_])*"
		NUMBER_LITERAL = "regexp:[0-9]+(\.[0-9]+)?"
		STRING_LITERAL = "regexp:\"[^\r\n\"]*\""
		LINE_COMMENT = "regexp://.*"
		BLOCK_COMMENT = "regexp:/\*([^*]|\*+[^*/])*(\*+/)?"
		WHITESPACE = "regexp:[ \t\r\n]+"
	]
}

private DaedalusFile ::= { Definition }*
Definition ::= ( ConstDef | ClassDef | InstanceDef | VarDef | PrototypeDef ) ";"
ConstDef ::= "const" TypeReference NameNode "=" Literal {pin=1}
TypeReference ::= ReferenceNode | "void" | "float" | "int" | "string" | "func"
NameNode ::= IDENTIFIER_TOKEN
ReferenceNode ::= IDENTIFIER_TOKEN
Literal ::= NUMBER_LITERAL | STRING_LITERAL
ClassDef ::= "class" NameNode "{" { VarDef ";" }* "}" {pin=1}
VarDef ::= "var" TypeReference NameNode { "," NameNode }* [ ArrayIndex ] {pin=1}
ArrayIndex ::= "[" ( NUMBER_LITERAL | ReferenceNode ) "]" {pin=1}
InstanceDef ::= "instance" NameNode { "," NameNode }* "(" ReferenceNode ")" {pin=1}
PrototypeDef ::= "prototype" NameNode "(" ReferenceNode ")" "{" { Assignment ";" }* "}" {pin=1}
Assignment ::= ReferenceNode "=" Expression
Expression ::= Literal | ReferenceNode


//private ComplexExpressionNode ::= [ UnaryOperator ] ( Operand { Operator ComplexExpressionNode }* ) | ( "(" ComplexExpressionNode ")" { Operator ComplexExpressionNode }* )